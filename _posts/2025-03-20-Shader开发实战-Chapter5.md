---
title: "Shader开发实战Chapter5"
math: true
date: 2025-03-20 10:30:00 +0800
categories: [渲染管线]
tags: [shader]
---
## 深入光照

目前的场景只有一个单一的平行光照亮，这大大限制了项目画面的灵活性， 我们需要引入不同的光照类型

### 定向光源

渲染中使用的最简单也是最常见的光源，通常用来模拟无限远处的光源。以下是表示平行光的数据结构
![Pasted image 20250509161119.png](assets/img/Pasted image 20250509161119.png)
```
struct DirectionalLight
{
	glm::vec3 direction;
	glm::vec3 color;
	float intensity;
};
```

### 点光源

电光源也是常用光源，对其最形象的描述是将其比作一个灯泡，由一个发射点向四周投射光0线，与平行光不同它发出的光线都不平行。与现实生活中一样距离光源越近的物体接收到的光线越多，表现就是越亮
![Pasted image 20250509161528.png](assets/img/Pasted image 20250509161528.png)
```
struct PointLight
{
	glm::vec3 position;
	glm::vec3 color;
	float intensity;
	float radius;
};
```

>在点光源部署中，由于其会衰减的特性距离物体较远处的点光源对物体的光照贡献可能不太明显，但是在GPU计算中其性能开销是无法避免的特别是对于光照这样性能开销较大的资源

### 聚光灯

聚光灯的工作原理与点光源类似，但是不同的是它光投射出的是圆锥体而不是球体，其衰减特性也与点光源不一致。主要是计算片元是否在聚光灯的圆锥体内，使用接收片元上的lightDir点乘上聚光灯的lightConeDir将其与cutoff比较如果在其内则被照亮
![Pasted image 20250509162637.png](assets/img/Pasted image 20250509162637.png)

```
struct spotlight
{
	 glm::vec3 position;
	 glm::vec3 direction;
	 float cutoff;

	glm::vec3 color;
	float intensity;
}
```

### 多光源

有了多类型光源后我们就可以将其综合起来使用来增强画面的表现，但是多光源处理是一个经久不衰的主题在本书中主要介绍了两中不同的处理方法

#### LightArray(single-pass)

我们使用一个光源数组来储存所有不同类型的光源，然后在片元着色器中同时计算这些已知光源对物体的光照贡献最后进行一次drawcall绘制出画面帧

该方法的缺点也很明显不够灵活，无法添加比预先硬编码更多的光源；即使只有一个光源对场景有贡献我们也要付出五个光源的性能代价

#### Multi-pass

核心思想是对每一个光源进行单独一次绘制即对每个光源进行一次drawcall和shader计算，计算完毕之后在颜色缓冲器中多个将多个绘制的颜色进行混合(blending)，每一次单独计算即为一个pass。由此可见我们可以灵活地增加pass的数量来改变场景中光源的数量，也便于我们对单个光源进行控制。但是在复杂场景中其性能开销可能巨大(光源数量乘上物体数量)

#### forward rendering & deferred rendering

本书中介绍的这两种渲染方法都是前向渲染，除此之外还有延迟渲染技术这两种方法的应用场景有所不同

前向渲染是一种传统的渲染方法，其基本流程是：

1. **逐物体渲染**：对于场景中的每一个物体，依次进行渲染。
2. **逐像素计算光照**：在片元着色器阶段，针对每一个像素，计算其受到的所有光源的影响。
3. **输出最终颜色**：将计算结果输出到帧缓冲区，形成最终图像

这种方法在处理少量光源和透明物体时表现良好

延迟渲染将渲染过程分为两个主要阶段：

1. **几何阶段（Geometry Pass）**：渲染场景中的所有物体，将每个像素的几何信息（如位置、法线、颜色等）存储到多个缓冲区中，统称为G-Buffer
2. **光照阶段（Lighting Pass）**：利用G-Buffer中的信息，计算每个像素的光照，生成最终图像

这种方法在处理大量光源时具有优势

|特性|前向渲染|延迟渲染|
|---|---|---|
|光照计算|每个物体每个像素计算所有光源|每个像素计算所有光源|
|光源数量支持|少量光源|大量光源|
|透明物体支持|良好|较差（需额外处理）|
|抗锯齿支持|支持MSAA等传统抗锯齿技术|传统MSAA支持差，需使用其他技术|
|内存占用|较低|较高（需要多个G-Buffer）|
|实现复杂度|较低|较高|
|后期处理支持|较差|良好|
在实际应用中，许多现代引擎采用混合渲染路径，即同时使用前向渲染和延迟渲染
- 使用延迟渲染处理不透明物体和大部分光照计算
- 使用前向渲染处理透明物体和特殊效果
这种方法结合了两者的优点，适应更复杂的渲染需求

## 剖析着色器性能

### CPU时间和GPU时间

CPU和GPU通常不完全同步，游戏帧的渲染速度通常取决于这两个不同的时间：CPU执行帧的所有逻辑并将图形命令发送到GPU的速度(CPU时间)，以及GPU执行这些命令的速度(称为GPU时间)。游戏的帧时间取决于这两个数字，且由这两个时间中较慢的时间决定
### 解决Vsync(垂直同步)

除了以上两个时间，游戏的渲染速度还取决于用户的显示器。显示器只能以特定的速度刷新显示信息

当渲染一帧的时候应用程序将渲染的结果绘制到一个缓冲区，称为后置缓冲区；显示器上当前显示的数据称为前置缓冲区。当显示新帧的时候将交换这两个缓冲区。问题是缓冲区的交换随时可能发生，即使显示器正在读取前置缓冲区并且显示数据时。当这种情况发生时，屏幕的一部分是来自旧缓冲区的数据，一部分是新缓冲区的数据，就会出现称为撕裂的视觉问题
![Pasted image 20250509173132.png](assets/img/Pasted image 20250509173132.png)

为了解决这个问题使用了vsync技术来延迟缓冲区的数据交换，在显示器刷新时缓冲区从不交换会对应用的帧率产生负面影响会分为以下两种情况

- 渲染速度远远快于显示器刷新速率，帧刷新时间会被强制同步为屏幕帧刷新速率
- 如果渲染速度稍慢于屏幕刷新速率可能会导致刚刚错过屏幕刷新检查点而导致延后到下一个刷新点，在这个情况下vsync会导致帧率非常低
### Nsight Graphics介绍
