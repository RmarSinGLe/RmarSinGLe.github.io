---
title: "Shader开发实战Chapter4"
math: true
date: 2025-03-18 10:30:00 +0800
categories: [渲染管线]
tags: [shader]
---
## 第一个光照模型

使用最常见的blinn-phong光照模型来渲染物体（在GAMES101已经有所学习）

### 镜面光照

当光线照射在光滑表面的时候，将产生镜面(specular)光照。因为物体十分光滑所以就会以一个特定角度反射出去，光在其他角度上的散射也就越少。这样就会形成闪亮的光斑

计算镜面光照首要要找到光线在片元上的反射方向，GLSL中为我们提供了这个方法
```
vec3 refl=refliect(-lightDir,normalVec);
```
有了反射向量之后还要计算从片元指向摄像机的方向向量
```
vec3 toCam=normalize(camPos-fragWorldPos);
```
接下来一步就是计算它们的点积，在这里我们可以进行幂次运算来提高反射高光的光泽度。指数越大反射的高光就越紧密
```
float specAmt=max(0.0,dot(refl,viewDir));
float specBrightness=pow(specAmt,16.0);
```
最后将brightness与灯光颜色和镜面反射颜色进行相乘

组合漫反射和就镜面反射光照就是在最后的输出上将两个值相加

### 环境光照

现实世界中灯光不必直接照射到物体上就能将其照亮。这是因为光线从其他物体上反射到其他物体上

原理是简单地向网格中的每个片元添加颜色，用场景光乘上网格表面的颜色防止添加不应该存在的颜色
```
vec3 ambient=ambientCol*meshCol;
outCol=vec4(diffCol+specCol+ambient,1.0);
```

### Phong光照模型

将以上三种光照模型结合到一起就是Phong光照模型，它的数学公式描述是
$$I_p=k_ai_a+\sum_{m\in lights}(k_d(\hat L_M \cdot \hat N)i_{m,d}+k_s(\hat R_m \cdot \hat V)^{\alpha}i_{m,s}$$
1. **环境光项：k_a i_a**
    
    - $k_a$：材质的环境光反射系数（RGB颜色），决定表面反射环境光的比例。
    - $i_a$：全局环境光强度（RGB颜色），模拟间接光照的均匀照明。
2. **漫反射项：$k_d (L̂_m · N̂) i_{m,d}$**
    
    - $k_d$：材质的漫反射系数（RGB颜色），控制表面如何散射光线。
    - $L̂_m$：归一化的光源方向向量，从表面点指向光源m。
    - **N̂**：表面点的单位法线向量。
    - $L̂_m · N̂$：点积计算光线与法线夹角的余弦（cosθ），值∈[0,1]，决定光线入射角的影响（实际计算时常取max(0, L̂·N̂)避免负数）。
    - $i_{m,d}$：光源m的漫反射强度（RGB颜色），通常结合光源颜色和衰减。
3. **镜面反射项：$k_s (R̂_m · V̂)^α i_{m,s}$
    
    - $k_s$：材质的镜面反射系数（RGB颜色），控制高光的颜色和强度。
    - $R̂_m$：反射光线向量，由公式 **R̂_m = 2(N̂·L̂_m)N̂ - L̂_m** 计算得到，表示光线L̂_m关于法线N̂的镜像方向。
    - **V̂**：视线方向向量，从表面点指向观察者。
    - $R̂_m · V̂$：点积衡量反射方向与视线的对齐程度，值∈[0,1]（实际计算取max(0, R̂·V̂)）。
    - **α**：高光指数，控制高光的锐利度（值越大，高光越集中）。
    - $i_{m,s}$：光源m的镜面强度（RGB颜色），通常与光源颜色一致。
**求和项：**

- **Σ**：对场景中所有光源（lights）的贡献求和，每个光源贡献漫反射和镜面反射两部分。

### Blinn-Phong光照

在Phong模型中某些视角可能对低光泽度的物体产生怪异的镜面反射阴影
![Pasted image 20250508215137.png](assets/img/Pasted image 20250508215137.png)
为了解决这个问题使用Blinn-Phong光照的变体，其中的主要差异是使用半程向量替换了镜面反射中的反射光向量
```
//phong
vec3 refl=reflect(-lightDir,nrm);
float specAmt=max(0.0,dot(refl,viewDir));
float specBright=pow(specAmt,16.0);

//blinn-phong
vec3 halfVec=normalize(viewDir+lightDir);
float specAmt=max(0.0,dot(halfvec,nrm));
flaot specBright=pow(specAmt,64.0);
```

### 使用纹理控制光照

在普通网格中物体都是均匀着色的，但是这个与我们游戏中所见到达的表现还有所不同。我们可以使用纹理来改变物体表面的光照信息。

除了普通的颜色纹理之外我们引入了镜面贴图（specmap）来控制网格不同曲面处的光泽度，基础逻辑是将片元上的高光乘以片元UV坐标的镜面贴图中的值。这允许控制那些片元是有光泽的，但是需要为网格的所有有光泽的部分设置一个固定的光泽值

## 法线贴图

为了渲染模型中的微小细节使用一种特殊的纹理贴图法线贴图（normalMap），这个贴图中存储的法线向量。因为是存储向量所以法线贴图中的RGB值其实是法线向量的XYZ坐标。

但是RGB格式中无法存储负值，使得许多向量无法表示。所以我们将0.5值视为0.0，这意味着颜色为(0,0.5,1)的像素代表的向量是(-1,0,1)这样做就不得不对法线贴图采样后进行额外的着色运算以便于将颜色值转化为所需的向量方向

法向量不是基于世界坐标也不是物体坐标而是一种特殊的坐标空间叫做切线空间，他是每一个片元的坐标空间，基于每个片元所来自的网格表面定义的

法线贴图的工作原理：将网格中的法向量替换为法线贴图中存储的法向量这个过程涉及到对象空间，世界空间以及切线空间的坐标变化。首先我们要创建切线，副切线和法线矩阵(TBN矩阵)，这个过程在顶点着色器中完成
![Pasted image 20250509155238.png](assets/img/Pasted image 20250509155238.png)

## 立方体贴图和天空盒

立方体贴图是一种特殊的纹理，它有六个单独的纹理组合而成。六个纹理可以构建出天空盒使得整个场景具有无缝的360°背景纹理

将立方体贴图应用于天空盒渲染时，因为需要将天空盒作为背景。从透视角度来看天空盒背景应该总是位于场景最远处，为了实现这个效果应该对天空盒贴图进行透视除法。在openGL中对物体坐标使用齐次坐标来实现透视效果，即为XYZW分量。W作为除数除以XYZ坐标来表示透视远近效果。在天空盒中我们需要将Z坐标值固定为1.0(屏幕坐标已经进行归一化)因此Z/W数值需要一直为1即Z和W数值相等

立方体贴图反射：为了使物体与场景看起来更加协调，我们对立方体贴图颜色进行采样并加入到光照计算的lightCol变量中